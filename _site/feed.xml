<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://www.sscit.de/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sscit.de/" rel="alternate" type="text/html" /><updated>2021-01-08T20:32:18+01:00</updated><id>https://www.sscit.de/feed.xml</id><title type="html">Technology and Future.</title><subtitle>Blog about software development and technological progress.</subtitle><author><name>Stefan Schlichthärle</name></author><entry><title type="html">Unit Testing with Google Test in Bazel</title><link href="https://www.sscit.de/2021/01/08/bazel-gtest.html" rel="alternate" type="text/html" title="Unit Testing with Google Test in Bazel" /><published>2021-01-08T18:05:31+01:00</published><updated>2021-01-08T18:05:31+01:00</updated><id>https://www.sscit.de/2021/01/08/bazel-gtest</id><content type="html" xml:base="https://www.sscit.de/2021/01/08/bazel-gtest.html">&lt;p&gt;&lt;a href=&quot;https://github.com/google/googletest&quot;&gt;Google Test&lt;/a&gt; is a well-established framework for unit tests in C++. It provides lots of features and can be used to write tests for own classes and their methods. Its integration in Bazel build system works quite well, with the benefit that it is not necessary to copy Google Test source files into the own repository or use Git submodules, as Google Test’s repository is downloaded on demand by Bazel during the build process. In this blog post, I will describe how &lt;a href=&quot;/2021/01/03/REL.html&quot;&gt;REL&lt;/a&gt; uses Google Test. This approach can easily be transferred to every C++ development project that uses Bazel as build system.&lt;/p&gt;

&lt;p&gt;First of all, Google Test has to be added as external dependency to the Bazel WORKSPACE file. Bazel’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_git_repository&lt;/code&gt; rule can be used for this.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new_git_repository(
    name = &quot;googletest&quot;,
    build_file = &quot;gmock.BUILD&quot;,
    remote = &quot;https://github.com/google/googletest&quot;,
    tag = &quot;release-1.10.0&quot;,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sscit/rel/blob/main/WORKSPACE#L3&quot;&gt;Source in REL project&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this snippet, Google Test’s public repo on Github is referenced, and a dedicated tag is selected. If there is a new version of Google Test available, it is sufficient to update the tag in this rule, to change the dependency for all unit tests in the workspace.&lt;/p&gt;

&lt;p&gt;As a second step, build file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gmock.BUILD&lt;/code&gt; is created in folder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;external&lt;/code&gt;. It contains the Bazel definitions for Google Test, so that the referenced code is available as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;’s&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cc_library(
    name = &quot;gtest&quot;,
    srcs = [
        &quot;googletest/src/gtest-all.cc&quot;,
        &quot;googlemock/src/gmock-all.cc&quot;,
    ],
    hdrs = glob([
        &quot;**/*.h&quot;,
        &quot;googletest/src/*.cc&quot;,
        &quot;googlemock/src/*.cc&quot;,
    ]),
    includes = [
        &quot;googlemock&quot;,
        &quot;googletest&quot;,
        &quot;googletest/include&quot;,
        &quot;googlemock/include&quot;,
    ],
    linkopts = [&quot;-pthread&quot;],
    visibility = [&quot;//visibility:public&quot;],
)

cc_library(
    name = &quot;gtest_main&quot;,
    srcs = [&quot;googlemock/src/gmock_main.cc&quot;],
    linkopts = [&quot;-pthread&quot;],
    visibility = [&quot;//visibility:public&quot;],
    deps = [&quot;:gtest&quot;],
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sscit/rel/blob/main/external/gmock.BUILD&quot;&gt;Source in REL project&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first library includes all Google Test related source files, whereas the second rule only contains the reference to Google Test’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Now Google Test is available in the build environment as external dependency. If it is required as part of a build, it is downloaded and built (and cached) by Bazel. To use it for own unittests, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gtest_main&lt;/code&gt; rule is referenced as dependency by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_test&lt;/code&gt; rule, which also includes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*Test.cpp&lt;/code&gt; - files, which contain the test cases.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cc_test(
    name = &quot;RelLibUnitTest&quot;,
    srcs = glob([&quot;**/*.cpp&quot;]),
    deps = [
        &quot;//rel-lib:rel_lib&quot;,
        &quot;@googletest//:gtest_main&quot;,
    ],
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sscit/rel/blob/main/rel-lib/test/unittest/BUILD&quot;&gt;Source in REL project&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_test&lt;/code&gt; is the “executable”, which brings together the test cases (in this example, added to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;srcs&lt;/code&gt;), the actual source code that shall be tested (dependency to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rel_lib&lt;/code&gt;) and the Google Test Framework, referenced as dependency, too.&lt;/p&gt;

&lt;p&gt;To run it, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bazel test //path/to:RelLibUnitTest&lt;/code&gt; is executed. Google Test logfiles are not printed out to the command line, they are stored in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/bazel-testlogs/path/to/RelLibUnitTest&lt;/code&gt;.&lt;/p&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">Google Test is a well-established framework for unit tests in C++. It provides lots of features and can be used to write tests for own classes and their methods. Its integration in Bazel build system works quite well, with the benefit that it is not necessary to copy Google Test source files into the own repository or use Git submodules, as Google Test’s repository is downloaded on demand by Bazel during the build process. In this blog post, I will describe how REL uses Google Test. This approach can easily be transferred to every C++ development project that uses Bazel as build system.</summary></entry><entry><title type="html">Building and Testing C++ Python Modules with Bazel</title><link href="https://www.sscit.de/2021/01/05/python-bazel.html" rel="alternate" type="text/html" title="Building and Testing C++ Python Modules with Bazel" /><published>2021-01-05T16:05:31+01:00</published><updated>2021-01-05T16:05:31+01:00</updated><id>https://www.sscit.de/2021/01/05/python-bazel</id><content type="html" xml:base="https://www.sscit.de/2021/01/05/python-bazel.html">&lt;p&gt;While working on &lt;a href=&quot;/2021/01/03/REL.html&quot;&gt;REL&lt;/a&gt;, I learned a lot about Bazel and its usage as build system in open source projects. In a series of blog posts, I will share these learnings and describe different approaches. Today’s blog post addresses the integration of C++-based Python modules into Bazel and the modelling of dependencies towards the corresponding Python-based tests.&lt;/p&gt;

&lt;p&gt;As part of REL’s Python integration, I created a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt; called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rel_py&lt;/code&gt; which includes the core REL C++ library and the necessary Python binding (using the ingenious &lt;a href=&quot;https://github.com/pybind/pybind11&quot;&gt;pybind11&lt;/a&gt; framework). If the library is built as dynamic library, the resulting &lt;em&gt;librel_py.so&lt;/em&gt; file can directly be imported in every Python script via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt; statement. It took me quite some time, though, to model the dependency between a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; rule and the mentioned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;. My goal was to add an integration test to Bazel, which uses REL within Python, to read a toy model and test the basic functionality, like accessing all type instances, checking the API etc.&lt;/p&gt;

&lt;p&gt;The integration test itself is a simple python script, that imports &lt;em&gt;librel_py.so&lt;/em&gt; and interacts with the API. I wrapped it into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; rule. At the moment, it is not possible, though, to model a dependency (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deps&lt;/code&gt;) in Bazel from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; towards &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;, as Bazel only allows dependencies towards rules from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_&lt;/code&gt; family. Therefore I tried the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; - attribute, which allows specifying arbitrary dependencies, e.g. to test data. Unfortunately, with this approach, I was not able to specify the correct import paths for the Python runtime. During test execution, Python always complained, that the module that shall be imported cannot be found.&lt;/p&gt;

&lt;p&gt;After searching on Stackoverflow and the Bazel bugtracker, I finally figured out the following approach, to get the dependencies right: Apparently it is necessary to define a dummy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_library&lt;/code&gt; first, which is modeled as dependency within the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_library&lt;/code&gt; then uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; attribute to point to a &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_binary&lt;/code&gt;&lt;/strong&gt; rule, which is located in the &lt;strong&gt;same folder&lt;/strong&gt; as the two py-rules, and is actually a copy of the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;. The disadvantage of this solution is definitely, that the Bazel model is partially duplicated. Nevertheless, the obvious advantage, it now works and I can run an integration test via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bazel test&lt;/code&gt;, that builds the Python binding library/binary of REL and runs a Python script, to test the functionality.&lt;/p&gt;

&lt;p&gt;My solution in Bazel can be found here: &lt;a href=&quot;https://github.com/sscit/rel/blob/main/relpy/test/BUILD&quot;&gt;https://github.com/sscit/rel/blob/main/relpy/test/BUILD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bazel Bugtracker issues related to this topic, that contain additional details:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bazelbuild/bazel/issues/1475&quot;&gt;https://github.com/bazelbuild/bazel/issues/1475&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bazelbuild/bazel/issues/701&quot;&gt;https://github.com/bazelbuild/bazel/issues/701&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">While working on REL, I learned a lot about Bazel and its usage as build system in open source projects. In a series of blog posts, I will share these learnings and describe different approaches. Today’s blog post addresses the integration of C++-based Python modules into Bazel and the modelling of dependencies towards the corresponding Python-based tests.</summary></entry><entry><title type="html">REL - Requirements Engineering Language</title><link href="https://www.sscit.de/2021/01/03/REL.html" rel="alternate" type="text/html" title="REL - Requirements Engineering Language" /><published>2021-01-03T21:05:31+01:00</published><updated>2021-01-03T21:05:31+01:00</updated><id>https://www.sscit.de/2021/01/03/REL</id><content type="html" xml:base="https://www.sscit.de/2021/01/03/REL.html">&lt;p&gt;In the last couple of weeks, I have been working on an open source project called &lt;a href=&quot;https://github.com/sscit/rel/blob/main/README.md&quot;&gt;REL - Requirements Engineering Language&lt;/a&gt;. Its core is a domain specific language, which enables requirements engineers to define a so called requirements model. The model contains type definitions and enumerations, which are then used to formally describe the actual “content”, i.e. the requirements written by developers. All data resides in text files, which can be committed into a git repository. Besides the DSL, the REL framework contains a (partially completed) implementation of the language server protocol, to get IDE support for the language, and python integration. For more technical details about the framework, have a look at the &lt;a href=&quot;https://github.com/sscit/rel/blob/main/README.md&quot;&gt;README.md&lt;/a&gt; on Github or the still growing &lt;a href=&quot;https://github.com/sscit/rel/blob/main/doc/developers_guide.md&quot;&gt;developer’s guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Requirements engineering in software projects always consists of three parts:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The actual content, which means the requirements that describe the resulting product and the metadata like attributes, links, comments to the requirements etc.&lt;/li&gt;
  &lt;li&gt;The tooling to manage the requirements (like DOORS or, yes, as usual, the multi-purpose powertool Excel)&lt;/li&gt;
  &lt;li&gt;The processes, that define how requirements work is done in the project, e.g. collaboration with partners, quality metrics, tracing of requirements towards tests and others.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2 and 3 are ideally covered by the requirements manager(s) of the project, whose role cover establishing processes and tools for requirements work within the project. Processes and tools, well documented and supporting an agile workflow, are the enabler for #1: All project members have to contribute to the “content”, as in most projects, the knowledge about the product is distributed among all team members. Based on my experience, projects often neglect the efforts to establish solid processes and tools for requirements engineering, which are ideally available right at the beginning of the project! If this is not the case, developers don’t know where to put their requirements, and in worst case, gradually loose track on this fundamental part of their (software) development work.&lt;/p&gt;

&lt;p&gt;To address this challenge, I created the REL framework, whose purpose is already well described in the &lt;a href=&quot;https://github.com/sscit/rel/blob/main/doc/developers_guide.md&quot;&gt;developers guide&lt;/a&gt;, therefore I quote it here again:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In a nutshell, the REL framework shall enable requirements engineers to define a requirements model and the corresponding processes, which helps the whole team to focus on the actual work of writing valuable requirements. With the domain specific language as core element, well-known agile processes can be applied. The tooling provided in the framework is focusing on clear usecases, and always provides hooks for project-specific extensions. In an ideal world, requirements engineers use the REL framework to define tooling and processes upfront, so that developers can then focus on the creative work of writing requirements.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">In the last couple of weeks, I have been working on an open source project called REL - Requirements Engineering Language. Its core is a domain specific language, which enables requirements engineers to define a so called requirements model. The model contains type definitions and enumerations, which are then used to formally describe the actual “content”, i.e. the requirements written by developers. All data resides in text files, which can be committed into a git repository. Besides the DSL, the REL framework contains a (partially completed) implementation of the language server protocol, to get IDE support for the language, and python integration. For more technical details about the framework, have a look at the README.md on Github or the still growing developer’s guide.</summary></entry><entry><title type="html">Website Relaunch</title><link href="https://www.sscit.de/2020/12/29/first-post.html" rel="alternate" type="text/html" title="Website Relaunch" /><published>2020-12-29T21:05:31+01:00</published><updated>2020-12-29T21:05:31+01:00</updated><id>https://www.sscit.de/2020/12/29/first-post</id><content type="html" xml:base="https://www.sscit.de/2020/12/29/first-post.html">&lt;p&gt;I finally re-enabled my website sscit.de, after couple of years being disabled. In future, I plan to publish technical articles related to technology, mostly computer science, and maybe some related fields.&lt;/p&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">I finally re-enabled my website sscit.de, after couple of years being disabled. In future, I plan to publish technical articles related to technology, mostly computer science, and maybe some related fields.</summary></entry></feed>