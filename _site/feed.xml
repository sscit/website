<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://www.sscit.de/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sscit.de/" rel="alternate" type="text/html" /><updated>2021-01-05T16:36:33+01:00</updated><id>https://www.sscit.de/feed.xml</id><title type="html">Technology and Future.</title><subtitle>Blog about software development and technological progress.</subtitle><author><name>Stefan Schlichthärle</name></author><entry><title type="html">Building and testing C++ Python modules with Bazel</title><link href="https://www.sscit.de/2021/01/05/python-bazel.html" rel="alternate" type="text/html" title="Building and testing C++ Python modules with Bazel" /><published>2021-01-05T16:05:31+01:00</published><updated>2021-01-05T16:05:31+01:00</updated><id>https://www.sscit.de/2021/01/05/python-bazel</id><content type="html" xml:base="https://www.sscit.de/2021/01/05/python-bazel.html">&lt;p&gt;While working on &lt;a href=&quot;/2021/01/03/REL.html&quot;&gt;REL&lt;/a&gt;, I learned a lot about Python’s integration in Bazel and the current limitations and workarounds of the build system.&lt;/p&gt;

&lt;p&gt;As part of REL’s Python integration, I created a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt; called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rel_py&lt;/code&gt; which includes the core REL C++ library and the necessary Python binding (using the ingenious &lt;a href=&quot;https://github.com/pybind/pybind11&quot;&gt;pybind11&lt;/a&gt; framework). If the library is built as dynamic library, the resulting &lt;em&gt;librel_py.so&lt;/em&gt; file can directly be imported in every Python script via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt; statement. It took me quite some time, though, to model the dependency between a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; rule and the mentioned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;. My goal was to add an integration test to Bazel, which uses REL within Python, to read a toy model and test the basic functionality, like accessing all type instances, checking the API etc.&lt;/p&gt;

&lt;p&gt;The integration test itself is a simple python script, that imports &lt;em&gt;librel_py.so&lt;/em&gt; and interacts with the API. I wrapped it into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; rule. At the moment, it is not possible, though, to model a dependency (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deps&lt;/code&gt;) in Bazel from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt; towards &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;, as Bazel only allows dependencies towards rules from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_&lt;/code&gt; family. Therefore I tried the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; - attribute, which allows specifying arbitrary dependencies, e.g. to test data. Unfortunately, with this approach, I was not able to specify the correct import paths for the Python runtime. During test execution, Python always complained, that the module that shall be imported cannot be found.&lt;/p&gt;

&lt;p&gt;After searching on Stackoverflow and the Bazel bugtracker, I finally figured out the following approach, to get the dependencies right: Apparently it is necessary to define a dummy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_library&lt;/code&gt; first, which is modeled as dependency within the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_test&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_library&lt;/code&gt; then uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; attribute to point to a &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_binary&lt;/code&gt;&lt;/strong&gt; rule, which is located in the &lt;strong&gt;same folder&lt;/strong&gt; as the two py-rules, and is actually a copy of the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc_library&lt;/code&gt;. The disadvantage of this solution is definitely, that the Bazel model is partially duplicated. Nevertheless, the obvious advantage, it now works and I can run an integration test via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bazel test&lt;/code&gt;, that builds the Python binding library/binary of REL and runs a Python script, to test the functionality.&lt;/p&gt;

&lt;p&gt;My solution in Bazel can be found here: &lt;a href=&quot;https://github.com/sscit/rel/blob/main/relpy/test/BUILD&quot;&gt;https://github.com/sscit/rel/blob/main/relpy/test/BUILD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bazel Bugtracker issues related to this topic, that contain additional details:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bazelbuild/bazel/issues/1475&quot;&gt;https://github.com/bazelbuild/bazel/issues/1475&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bazelbuild/bazel/issues/701&quot;&gt;https://github.com/bazelbuild/bazel/issues/701&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">While working on REL, I learned a lot about Python’s integration in Bazel and the current limitations and workarounds of the build system.</summary></entry><entry><title type="html">REL - Requirements Engineering Language</title><link href="https://www.sscit.de/2021/01/03/REL.html" rel="alternate" type="text/html" title="REL - Requirements Engineering Language" /><published>2021-01-03T21:05:31+01:00</published><updated>2021-01-03T21:05:31+01:00</updated><id>https://www.sscit.de/2021/01/03/REL</id><content type="html" xml:base="https://www.sscit.de/2021/01/03/REL.html">&lt;p&gt;In the last couple of weeks, I have been working on an open source project called &lt;a href=&quot;https://github.com/sscit/rel/blob/main/README.md&quot;&gt;REL - Requirements Engineering Language&lt;/a&gt;. Its core is a domain specific language, which enables requirements engineers to define a so called requirements model. The model contains type definitions and enumerations, which are then used to formally describe the actual “content”, i.e. the requirements written by developers. All data resides in text files, which can be committed into a git repository. Besides the DSL, the REL framework contains a (partially completed) implementation of the language server protocol, to get IDE support for the language, and python integration. For more technical details about the framework, have a look at the &lt;a href=&quot;https://github.com/sscit/rel/blob/main/README.md&quot;&gt;README.md&lt;/a&gt; on Github or the still growing &lt;a href=&quot;https://github.com/sscit/rel/blob/main/doc/developers_guide.md&quot;&gt;developer’s guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Requirements engineering in software projects always consists of three parts:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The actual content, which means the requirements that describe the resulting product and the metadata like attributes, links, comments to the requirements etc.&lt;/li&gt;
  &lt;li&gt;The tooling to manage the requirements (like DOORS or, yes, as usual, the multi-purpose powertool Excel)&lt;/li&gt;
  &lt;li&gt;The processes, that define how requirements work is done in the project, e.g. collaboration with partners, quality metrics, tracing of requirements towards tests and others.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2 and 3 are ideally covered by the requirements manager(s) of the project, whose role cover establishing processes and tools for requirements work within the project. Processes and tools, well documented and supporting an agile workflow, are the enabler for #1: All project members have to contribute to the “content”, as in most projects, the knowledge about the product is distributed among all team members. Based on my experience, projects often neglect the efforts to establish solid processes and tools for requirements engineering, which are ideally available right at the beginning of the project! If this is not the case, developers don’t know where to put their requirements, and in worst case, gradually loose track on this fundamental part of their (software) development work.&lt;/p&gt;

&lt;p&gt;To address this challenge, I created the REL framework, whose purpose is already well described in the &lt;a href=&quot;https://github.com/sscit/rel/blob/main/doc/developers_guide.md&quot;&gt;developers guide&lt;/a&gt;, therefore I quote it here again:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In a nutshell, the REL framework shall enable requirements engineers to define a requirements model and the corresponding processes, which helps the whole team to focus on the actual work of writing valuable requirements. With the domain specific language as core element, well-known agile processes can be applied. The tooling provided in the framework is focusing on clear usecases, and always provides hooks for project-specific extensions. In an ideal world, requirements engineers use the REL framework to define tooling and processes upfront, so that developers can then focus on the creative work of writing requirements.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">In the last couple of weeks, I have been working on an open source project called REL - Requirements Engineering Language. Its core is a domain specific language, which enables requirements engineers to define a so called requirements model. The model contains type definitions and enumerations, which are then used to formally describe the actual “content”, i.e. the requirements written by developers. All data resides in text files, which can be committed into a git repository. Besides the DSL, the REL framework contains a (partially completed) implementation of the language server protocol, to get IDE support for the language, and python integration. For more technical details about the framework, have a look at the README.md on Github or the still growing developer’s guide.</summary></entry><entry><title type="html">Website Relaunch</title><link href="https://www.sscit.de/2020/12/29/first-post.html" rel="alternate" type="text/html" title="Website Relaunch" /><published>2020-12-29T21:05:31+01:00</published><updated>2020-12-29T21:05:31+01:00</updated><id>https://www.sscit.de/2020/12/29/first-post</id><content type="html" xml:base="https://www.sscit.de/2020/12/29/first-post.html">&lt;p&gt;I finally re-enabled my website sscit.de, after couple of years being disabled. In future, I plan to publish technical articles related to technology, mostly computer science, and maybe some related fields.&lt;/p&gt;</content><author><name>Stefan Schlichthärle</name></author><summary type="html">I finally re-enabled my website sscit.de, after couple of years being disabled. In future, I plan to publish technical articles related to technology, mostly computer science, and maybe some related fields.</summary></entry></feed>